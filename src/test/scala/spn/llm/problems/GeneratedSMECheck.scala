package spn.llm.problems

import org.scalacheck.*
import org.scalacheck.Prop.forAll
import spn.SPN.{SPN, toCTMC}
import spn.SPNSimulationPlot.plot
import spn.dsl.Reflection.reflect
import spn.llm.OllamaClient.{Model, askToModel}
import u07.modelling.CTMCSimulation.newSimulationTrace
import utils.MSet

/** Verifies that the right semantic of the Stochastic Mutual Exclusion SPN generated by the LLMs. */
object GeneratedSMECheck extends Properties("Stochastic Mutual Exclusion SPN"):

  val criticalSectionPlace: String = "CS"

  val prompts: Gen[String] = Gen.oneOf(
    s"Provide me a Stochastic Petri Net representing a Stochastic Mutual Exclusion system with various rates. " +
      s"Mandatory Requirement: The Critical section place must be named $criticalSectionPlace",
    s"Give me a SPN representing a Stochastic Mutual Exclusion system" +
      s"The Critical section place must be named $criticalSectionPlace",
    s"Can you provide me a SPN representing a Stochastic Mutual Exclusion system using inhibitor arcs?" +
      s"The Critical section place must be named $criticalSectionPlace",
  )
  val models: Gen[Model] = Gen.oneOf(Set(Model.Gemma2))

  val spns: Gen[Option[SPN[Any]]] = for
    model <- models
    prompt <- prompts
  yield reflect(askToModel(model, prompt))

  override def overrideParameters(p: Test.Parameters): Test.Parameters =
    super.overrideParameters(p).withMinSuccessfulTests(2)

  property("Critical Section place can have at most one token at a time") = {
    forAll(spns): (spnOpt: Option[SPN[Any]]) =>
      val allPlaces: List[Any] = spnOpt.get
        .flatMap(trn => trn.cond.asList ++ trn.eff.asList ++ trn.inh.asList)
        .toList
        .distinct

      val csPlace: Any = allPlaces.find(_.toString == criticalSectionPlace).get
      println("All places: " + allPlaces)
      println("CS place: " + csPlace)
      val simulation = toCTMC(spnOpt.get)
        .newSimulationTrace(MSet.ofList(allPlaces.filter(_ != csPlace)), new java.util.Random)
        .take(100)
        .toList

//      simulation.plot()
      simulation forall { _.state.filter(_ == csPlace).size <= 1 }
  }
